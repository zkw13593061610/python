## 数据库

关系型数据库               

mysql  免费，开源   y小写，其他大写 正确写法

阿帕奇

模型即为数据

```py
mysql 的配置项在隐藏文件里面，需要使隐藏的文件显示出来，有个 program data    my.ini  文件
```



### 基础命令：

``` py
安装mysql 服务  1.命令行  2.软件  3.程序存入数据

mysql-server  存储数据   mysql-client  命令行操作数据库

mysql -hlocalhost -uroot -p

show databases；显示房间信息

create database yueyingjun;  创建库

use yuejingju;   使用库

show tables;  查看表    gbk   gb2312 utf-8 比gbk多一个字节

create table  stu(id int(10)(2的32次方) (制定存储类型) auto_increment primary key(组件，帮助我们快速查询数据),name varchar(255)(字符床存储格式),age varchar(10),sex varchar(10) )default charset=utf8   指定编码格式，输入的东西有很多，计算机无法识别。

添加表头：alter table stu add tel date;
修改表的数据类型：alter table stu modify column age int（10）

desc  stu; 查看表结构

insert into  stu (name,age,sex) values('张三'.'男','20') 插入数据

select * from stu  查看表的信息

update stu set name='list' where id=1   修改表的信息

alter table person change stu_name name varchar(25); 修改表头
这里stu_name是原名，name是新名 
注意，不管改不改数据类型，后面的数据类型都要写 
如果不修改数据类型只需写成原来的数据类型即可

delete from stu where id=2;

增删改查
-hhostname -uusername -ppassword -Pport 3306  端口
1.登陆
2，查看所有库
3，创建库
4，使用库
5，创建表
6，插入数据
7.查询数据
8.更新数据
9.删除数据
10.删除表
	drop table 表名
11.删除库
	drop database 库名
有联系的进行查询
select * from category inner join category_info on category.cid=category_info.id   交集    多余的不会出现
select * from category left join category_info on category.cid=category_info.id   以左边为准
select * from category right join category_info on category.cid=category_info.id   以右边为准
select category.cid,cname,GROP_CONCAT（step），GROP_CONCAT（step） from category left join category_info on category.cid=category_info.id      GROUP BY 分组查询
date 年月日  datetime  年月日时分秒  current_timestamp 时间戳   1970
```

### bs与cs架构：

```py
c/s架构  安装应用   --客户--服务端--客户

b/s 架构  基于浏览器的服务器

混合型开发，两种都有
/cs     延迟组要在硬件的性能，可控   ，缺点，必须有客户端，更新不及时

/bs     可以随时访问最新的内容，免去用户的下载  有延迟。不可控。不能够流畅的去操作，体验性不好

所以才会出现ajax  结合两者的优点  
怎么样让基于/bs  架构 

script   ajax    

async  js  and xml    我们利用js异步的能力来处理数据      异步是啥
```

flask  tormado  

 非关系型数据库

 数据仓库   

async  js  and xml   ajax

pip3 install 

sudo insatll flask

from flask import flask

pip flask install

laos -p | grep 6000   python中寻找

html又叫模板  

模板渲染



pymysql   

from     可以添加相对路径

import    直接导入  这里面的点代表路径  b.b.b

python基于模块，开源和分享

sys python系统模块

sys.path   这个表明了只要你把文件放在这里面的目录，都可以访问   site-packages  pip 安装的时候默认 ， 如果搜说路径里面没有的话，可以添加搜索路径 os.path.append(路径)

1.内置模块    python自己带的功能   直接import  就可以

2.自定义模块

3.第三方模块

模块的创建

虚拟环境

引进来的包只会执行一次

```
sudo  apt-get install  python3.4-venv  安装虚拟环境
python3 -m venv tutorial-env(虚拟环境文件名称)
cd tutorial-env
source bin/activate （运行虚拟环境）

```

python  ipython

network    

静态文件  css  js  创建一个特殊的static

{%for%}

{{    item.name}}

{%endfor%}

gui    服务器（最擅长）   运维   数据处理（此擅长）

配置 模板 数据

container

localtion.href('url')   从当前页面跳转到另一页面

readnoly    只能读的状态

type=hidden    隐藏   

vim-gtk

post 传的是内容，get是通过地址栏传递信息的

ajax= newXM lhttprequest（）

ajax。onload=function（ev）{

var 

}

ajax.open（‘get’，‘2.html’）方式，地点

ajax.send（）

### ajax:

```py
ajax.onreadystatechange=function（）
ajax.readystate
ajax.status
ajax.response
一般只有四个步骤：
	1.创建对象 let ajax=new XMLHTTPRequest()
	2.监听过程 ajax.onload=function(){
        
	}
	3.安排任务 ajax.open('get','/url')   第一个参数是以什么方式获取，第二个参数是去哪里寻找 第一个参数还可以以post方式获取，但这个方式有点不一样，首先指定获取方式为post，但要在send里面进行数据的传递,然后需要再添加一个方法，ajax.setRequestHeader('content-type','application/x-www-form-urlencoded')
	4.发送  ajax.send()    
	open 里面有五个参数，第三个是同步与异步，同步时一起发生，异步是互不影响，默认是异步，true，如果是false ，则为同步，第四五个是用户名和密码，但如果在自己的服务器上面，不需要输入这些东西
1.ajax解决的问题：
	1.页面跳转的问题
	2.用户的交互就是用户的体验度
	3.异步的获取或者传递数据
	4.操作效率
	老师的总结：
		1.页面无刷新操作数据
		2.按需获取的问题   第一次还没加载，但是过去之后加载了
		3.让基于bs架构的软件能成为想基于cs架构的软件操作流畅
2.ajax的使用   立用js异步地能力
3.new XMLHTTPRequest()
4.open（） send（） onload
5.可以处理多种返回类型的返回的数据（text，json，blob，arraybuffer，document）
6.传递数据  get post

地址
方式
返回的类型
传递的数据
最终的处理结果
function（）{
    
}
参数初始化
data.
success(){}
json.dumps(result)   把json对象转化为json字符串
```

函数   即使对应法则

doctype  html   浏览器以那种方式解析下面的代码

兼容性问题     生产缠上不一样   版本不一样

html又叫  树文档 ，

html 是xml的一种扩展

html 称为模板，数据又叫模型  

svg 表示矢量图

xml定义了一种语言的规范，   标签文档（很多标签组成）  树文档（组织结构来说）

ajax的返回值 

MDN文档     XMLHTTPRequest

### 插入图片：

```py
file=new filereader()]

file,onload=function(ev2){}

document.queryselector('img').src=ev2.target.result
```

### 后台语言   python pip java c++

### URI：

```py
在电脑术语中，统一资源标识符（Uniform Resource Identifier，或URI)是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义
url  是uri的一种   一个资源在互联网总的唯一地点   统一资源标识符
url 遵循http协议
地址栏的组成：协议://域名/目录/文件#片段标示符（例如：/a/b.php#a）
uri 协议，主机ip地址给，主机资源的具体地址，如目录和文件名等
```



#锚链结    后面带着锚链接， 锚链接和？不会同时出现   不会向服务器发生请求，地址栏发生变化，有历史纪录，锚链接是对本地资源的一种定位，锚链接一般都带#号，#和？一般不会同时出现

uri  定位资源的方式，url是通过http规定的地址的方式，他是uri的一种

协议   http https   svn   统称tcp/ip协议

协议://（用户名：密码@）主机的名字：端口/路径/文件名？查询字符串#锚链接

锚链接  也叫hash值

http://   baidu.com/a/b/

单线程异步机制    js

django   pillow scrapy   numpy

### jquery:

```py
query 查询  j   js 解决兼容性问题  1.15  3.0  运行小路高，不解决兼容问题
```

数据传递方式  搜索引擎  百度  

seo  搜索引擎 优化   讲究技术

 sem     花钱   

路径   /show/<id>   show(id)    

### 下载flask

```py
pip install flask
```

### 下载pymysql

```py
pip install pymysql
```

### 区块链 解决信任问题  加密技术

### 跨境电商  解决 外贸 全球化      行业  外贸规则

vr的原理

需求分析  uml  啥玩意

a链接默认当前路径

data['source'] | safe 让浏览器认为这是安全的js，可以进行解析

processon   在线作图

1生成excel 数据

​	得到相应数据（数据库里面）

​	转换数据格式

​	写入excel

2.下载

http-content  浏览器支持

将文件导入数据库      必须在mysql 环境下  source  路径/库名 

​    input.select()  复制input里面的内容  

```
copy_target.focus();
copy_target.select();
try{
    if(document.execCommand('copy', false, null)){
        //success info
    } else{
        //fail info
    }
} catch(err){
    //fail info
}   这里是检查是否被复制
```
```py
create table if not exits stu
--空格  代表注释   #代表注释
sql注入

select * from user where uname="" or 1=1;-- "and upass="123456";
会输出所有信息



select logs.*,stu.name as sname,classes.name as cname from logs left join stu on logs.phone=stu.phone left join classes on stu.classid=classes.id where logs.phone in (select phone from stu where classid in (select id from classes where fid in (10))) 
date_format(logs.time，‘%Y——%m-%d’ as time或者   ='2018-11-13')

方向：<select name='category'>
	<option value=''> 请选择方向
方向：<select name='category'>
	<option value=''> 请选择方向
方向：<select name='category'>
	<option value=''> 请选择方向
	
<button>

子查询
select * from logs where id in (1,2,3)   在里面查出来1，2，3
select  * from logs where phone in (select phone from stu where classid in (select id from classes where fid in(select cid from category where )))
```

### mysql函数：

```py
date_format()   group_concat()    group by     limit
```

特点：

- 开源
- 支持大型的数据库
- 使用标准的SQL数据语言形式
- 可以运行于多种系统中，支持多种语言掉用
- 5000万
- 定制，即修改，GPL协议

### DCL  Database Controll Language 数据库控制语言，用来设置或更改数据库：

net stop serve

超级管理员才拥有的权限

访问控制和权限：

来当客户端连接到服务器时，Mysql访问控制有两个阶段

连接验证：

- 连接到

请求验证

mysql -u 用户名  -p密码  -h 服务器IP地址 -P 服务器端口Mysql端口号   -D 数据库名

检验用户名密码；show databases 即有没有权利去用这些命令

默认表：

- mysql，user表：包含账户和全局权限列
- db表：包含数据库级的权限 
- table——priv和columns——priv   包含表级和列级权限
- procs——priv表：包含存储函数和

#### 创建账户：

- create user 账户名称  IDENTIFIED BY   password（username@hostname）

  ```py
  create user zkw@localhost identified by '123456'
  ```

  

#### 查询用户的权限：

- show grants for username@localhost    

  ```py
  *.*  什么权限都没有
  ```

@%.alibaba.com   % 代表子域名，可以在百度上看一下啊

省略就是%一样 或者（-）

#### 删除账户：

- DROP user  user，【user】

#### 设置权限：

- grant privilege （权限） all为所有   on 库名(*.*)  to   user  【密码】【连接方式】【指定其他人是否可以更改你的权限】   （with grant option）（别人可以更改你的权限）
- 首先，在grant关键字之后指定一个或多个权限，
- 接下来，指定确定特权

设置指定权限：

- grant select，update，insert on  localhost  to rfc
- create user rfc IDENTIFIED by ‘123564’ 

允许远程连接：

```py
grant all privileges on *.* to zkw@'%' identified by '123456' with grant option 
grant all privileges on .   to 'root'@'%' identified by 'mysql'  with grant option; flush privileges(刷新)
```



#### 撤销权限：

- revoke  权限 on 权限级别 （哪个库，那个表）  from user（账户）
- revoke 权限，grant option from user

#### 修改密码：

- set password for 用户名@localhost = ’新密码‘；
- update user set password=password（‘123456’） where user = ‘root’  and host = ‘localhost’；flush privileges
- mysqladmin -u用户名 -p旧密码 password新密码    这里有问题，没法修改
- 第四种方法：
  - 关闭正在运行的mysql服务
  - 打开DOS窗口，转到mysql/bin目录
  - 输入   mysqld --skip-grant-tables  跳过权限检查
  - 在打开一个DOS窗口,转到mysql/bin目录
  - 输入mysql回车
  - 链接权限数据库 use mysql
  - 改密码  update user set password=password（‘123’） where user = 'root'
  - 刷新

### 将文件导入数据库：

```py
常用
source 命令
进入mysql数据库控制台，如
mysql -u root -p
mysql>use 数据库
然后使用source命令，后面参数为脚本文件(如这里用到的.sql)
mysql>source d:/dbname.sql



navicat    使用 ，导入导出文件使用 转储为sql文件，执行sql文件，不要用备份，因为备份的话会因为版本不同而有差异
```



#### 数据库备份：

```py
shell> mysqldump --databases db1 db2 db3 > dump.sql
该--databases选项使命令行上的所有名称都被视为数据库名称。如果没有此选项，mysqldump会将第一个名称视为数据库名称，将后续名称视为表名称。
```



- mysqldump -u 【username】(用户名) -p【password】 【database__name】（要备份的数据库名称）>（重定向）[dump_file.sql](要生成的存储文件

仅备份数据库结构：

- mysqldump -u 【username】(用户名) -p【password】--no-data 【database__name】（要备份的数据库名称）>（重定向）[dump_file.sql](要生成的存储文件

仅备份数据库数据：

- mysqldump -u 【username】(用户名) -p【password】--no--create-info 【database__name】（要备份的数据库名称）>（重定向）[dump_file.sql](要生成的存储文件

导出多个数据库：

- mysqldump -u 【username】(用户名) -p【password】 【database__name,...】（要备份的数据库名称）>（重定向）[dump_file.sql](要生成的存储文件     可以指定多个
- mysqldump -u 【username】(用户名) -p【password】 --all-database（要备份的数据库名称）>（重定向）[dump_file.sql](要生成的存储文件

#### 查询：

- 查看表的类型   show full tables
- 查看某一列   show columns from teach     show columns  from teach like ‘id’   show columns  from teach like ‘%e%’   带e的   show columns  from teach where  Field=‘name‘
- 查看用户信息：
  - 1use mysql        2 select user from user
  - 看当前用户信息   select  user（）；
  - 当前登陆的用户   select user,host,db,command   from information_schema.processlist

#### 数据库维护：会把表给锁住   InnoDB      

- ##### 分析表语句

  - analyze  table 表名
    - table   表名
    - op  执行的操作
    - type    信息类型，状态
    - text    显示信息
- ##### 检查语句

  - check table 表名
- ##### 优化语句     一系列的操作导致产生碎片

  - optimize  table 表名
- ##### 修复表语句：

  - repair table 表名

### DDL    数据库定义语言  create truncate

#### 创建数据库

- create database  [  if not  exists]  名称

#### 删除

- drop  database   名称

#### 创建表    null  赞地方，没东西     none 啥都没有

- create table 名称（）

- 首先，指定要在create table 子句

- column——name  data——type【size】（显示的宽度）（32位显示11位）  【not null|null】是否是主键   auto_increment   default (null)(默认值为null) engine=InnoDB（引擎）   default charset（字符集）= utf8   comment（注释）=‘示例’

  ```py
  unique  唯一的
  name varchar(10) unique（索引，唯一的，还有全文，普通）,sex enum('1','0'),defult
  show create table+名称
  primary key（'name'） 设置主键
  hobby set('睡觉','吃饭','运动') 字符集，插入的时候只能从中选几个，如果插入的内容不在这里，不会添加上去，
  default null    不设置的话 默认为null
  select  * from user where pass is null  查出是null的信息，但不能用等于
  ```

  

#### 修改表

- alter table user change [column] name name1 varchar(100) not null

  ```py
  not null   不传值的话就是空的 ，什么都没有  null的话 ，默认为null
  ```

- 添加    alter table user ADD sex enum('1','2') [first|after 字段名](什么都不写放在最后 not null 

- 删除   alter table drop

- 索引：总共有五种，index，fulltext，unique，主键，外键

  - 添加唯一索引：alter table table-name add unique（‘那一列’） 必须加括号，引号不需要
  - 添加全文索引：alter table table-name add fulltext（‘那一列’）
  - 添加普通索引：alter table table-name add index（‘那一列’）
  - 删除索引： alter table table-name drop index  +那一列,只能是index   语法如此  ，这里不需要加括号，也不用引号，必须是index，不管是什么索引
  - 没有修改索引，只能删除再添加

- 添加主键   alter table table——name add primary key（）

- 修改引擎：

  - alter table table-name engine=InnoDB   show engines    show create table 表名称 

- 修改自增值：

  - alter table 表名称   auto-increment=1 

- 数据类型：数值，字符，时间

  - tinyint    1 字节  （-128，127） 有符号    （0，255） 无符号  2的8次方

  - smallint  2 字节      2的16次方

  - mediumint  3 字节

  - int   4 字节

  - bigint  8字节

  - float   4 字节  单精度

  - double  8字节   双精度

  - decimal    decimal（m，d）  整数  ，小数

  - | 数据类型                                                     | 需要存储                                              |
    | ------------------------------------------------------------ | ----------------------------------------------------- |
    | [`TINYINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 1 byte                                                |
    | [`SMALLINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 2 bytes                                               |
    | [`MEDIUMINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 3 bytes                                               |
    | [`INT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html), [`INTEGER`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 4 bytes                                               |
    | [`BIGINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 8 bytes                                               |
    | BIT(*M*)                                                     | approximately (*M*+7)/8 bytes                         |
    | FLOAT(*p*)                                                   | 4 bytes if 0 <= *p* <= 24, 8 bytes if 25 <= *p* <= 53 |
    | [`FLOAT`](https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html) | 4 bytes                                               |
    | `DOUBLE [PRECISION]`, [`REAL`](https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html) | 8 bytes                                               |
    | `DECIMAL(*M*,*D*)`, `NUMERIC(*M*,*D*)`                       | Varies; see following discussion                      |

    | 类型        | 存储（字节） | 最小值签名    | 最小值无符号 | 最大值签名   | 最大值无符号 |
    | ----------- | ------------ | ------------- | ------------ | ------------ | ------------ |
    | `TINYINT`   | 1            | `-128`        | `0`          | `127`        | `255`        |
    | `SMALLINT`  | 2            | `-32768`      | `0`          | `32767`      | `65535`      |
    | `MEDIUMINT` | 3            | `-8388608`    | `0`          | `8388607`    | `16777215`   |
    | `INT`       | 4            | `-2147483648` | `0`          | `2147483647` | `4294967295` |
    | `BIGINT`    | 8            | `-263`        | `0`          | `263-1`      | `264-1`      |

    ```py
    什么是zerofill    数值前面的位数是否需要用0填充  有这个属性是无法表示负数的
    什么是显示宽度    是否要将数据类型对应的位数都用0来显示出来
    什么是无符号    是不是需要负数，如果是unsigned的话，就是正常的，有符号，就是各分两边
    
    
    - unsigned     无符号    
    - zerofill     指定这个属性的意思是  int（10）  写个300，剩下的7位用0填充，int决定数值的范围
     需要使用  change 修改 
    ```

- 字符类型：

  - char   0-255   定长字符  除了他  都是不定长的  速度快，对于小的字节，有点浪费空间
  - varchar  0-65535  变长字符串     速度慢，不会浪费空间
  - tinyblob  0-255   存储的是二进制字符串 
  - tinytext  0-255   短文本字符串
  - mediumblob   
  - mediumtext 9
  - blob  0-65535   
  - text   0-65535   长文本数据
  - enum   枚举
  - set    集合

- 日期类型：   传入类型不合法，设置为0

  - date    yyyy-mm-dd
  - time   hh：mm：ss
  - year   1901/2155     yyyy
  - datetime   yyyy-mm-dd   hh：mm：ss
  - timestamp  时间戳
  - mysql中，类型为timestamp，插入的时候默认为当前时间，修改一样，5.7版本以后才有用

- 引擎类型：查看索引  show engines

  - InnoDB   是一个健壮的事务性存储引擎，引入了行级锁定和外键约束
    - 更新密集的表   InnoDB 存储引擎特别适合处理多重并发的更新请求
    - 事务  InnoDB存储引擎是支持事务的标准Mysql 存储引擎
    - 自动灾难恢复 与其他存储方式不同，InnoDB 表能够自动从灾难中回复
    - 外键约束  Mysql 支持外键的存储引擎只有InnoDB
    - 需要事务支持，并且有较高的并发读取效率
  - MyISAM   读取速度特别快，不支持事务，不支持外键  不需要锁，存储为三这个文件，文件名和表名都一样，但是扩展名
    - .frm(存储表定义)   就是结构
    - MYD（MYData） 存储数据
    - MYI   （MYIndex）存储索引

- mysql 数据库存放位置：??

  - mysql使用MyISAM 引擎，数据库文件就包括.frm,.MYD,.MYI 默认存放安装目录 data里面
  - 而另一种是包括 .frm,.ibdata1,ibd,默认存放目录是data文件夹

- 索引类型：

  - 主键索引   primary
    - 一个表中只能是唯一的，在数据的查询，写入，独处能够按照一定的顺序，一定排列进行有序的操作，并且除了主键外的其他字段都会受其影响
    - 主讲的值只能是唯一的，不能重复，auto——increment
  - 唯一键   unique
    - 一个表中能够给多个字段设置，形成一定的顺序，分组查询，设置后，字段里面的值不能重复 ，null除外
  - 普通的索引   index
    - 一个表中能够给多个字段设置
  - 文本索引  fulltext   5.7以后
    - 文本编辑器
    - 能够帮助我们快速的   大批量的文本当中，查找关键字或者查找指定内容

- 外键：  两个表进行关联：

  - 定义   一个附表的非主键字段和主表的主键字段进行关联的话，非主键字段我们叫做是外键

  - 作用：

    - 如果在附表当中添加一个主键里面不存在的数据，插入操作会报错
    - 如果在主表中进行数据的删除与更新，而附表的内容与之关联，是不会让你删除或者进行其他的操作

  - 语法：

    - [给约束起个名字    constraint + 名字 不需要加引号]   foreign key 【外键名】（columns）reference  classes【主表】外键名（cid） 

      ```py
       create table student(
          -> sid int(10) auto_increment primary key,
          -> sname varchar(255),
          -> cid int(10),
          -> CONSTRAINT aaa FOREIGN KEY (cid) references classes (cid))default charset=utf8;
          
          外键名称，外键名称，默认为第一个写的外键名，本表中的字段以来与另外一个表中的字段
      ```

  - 添加外键   alter table 表名 add constraint FK_ID foreign key(你的外键字段名) REFERENCES 外表表名(对应的表的主键字段名); 

    ```py
    alter table student add constraint 【aaa】 foreign key(cid) references classes (cid) on DELETE set null;
    on DELETE/UPDATE  district（默认，即报错）/cascade（关联,意思就是删除一个，关联的所有都删除）/set null(将关联的数据设置为null)/no action（什么也不做）student_ibfk_1
    ```

    

  - 删除外键  ALTER TABLE table-name DROP FOREIGN KEY key-id（外键名）; 删除约束

    ```py
    ALTER TABLE table-name DROP FOREIGN KEY key-id（约束名称）; 删除约束
    alter table stu drop key  aaa ;  删除外键名称
    ```

    

  - 查看外键  show create table locstock 

### DML   数据库操作语言   insert，update，delete三种指令为核心   导入表，导出表是啥

#### 插入语句

- 一次性插入多条信息

  ```py
  insert into stu(sid,sname,cid) values(12,'abc',1),(12,'abc',1),(12,'abc',1), on duplicate key update  stu.sid=stu.sid +1
  为了防止在插入信息的时候id重复
  insert into stu select * from stu1 on duplicate key update stu.sid=stu.sid +1
  ```

#### 删除语句 

- delete from 表名 order by /limit 数字

  ```py
  delete from stu order by id desc limit 1; 倒叙删除最后一个
  ```

- 关联删除：

  ```py
  delete teach,stu from teach,stu where teach.tname='老师40' and stu.tname='老师40'
  ```

- 清空数据：

  ```py
  deete from 表名  比较慢，虽然能讲全部的值进行清楚，但是自增的id不会减少
  truncate stu;
  清空，效率高，直接从0开始
  
  ```

  

#### 更新语句    table_type???

- update 【low_priority】(如果你在查询，等你查询完我在更新)【ignore】(忽略错误，后面会讲) 表名  set 字段 where  条件

- update curstomers set attr1=(select attr1 from )

  ```py
  select tname from teach order by id asc/desc   正序/反序
  select tname from teach order by rand()  随机排列
  select tname from teach order by rand() limit1 随机排列,选出一个
  update stu set tname=(select tname from teach order by rand() limit 1)where tname is null
  update ignore stu set name='张三' where id =5
  ```

- 关联更新

  - 第一种写法

    ```py
    update table1,table2,...  set 
    update table join on set 
    
    update stu,teach set stu.tname=teach.tname where stu.id=teach.id   更新那两个表，设置表里的那个字段，条件是这个表的字段，等于那个表的字段
    update xcs_user_credit_score a1,xcs_user_credit_score a2 set a1.user_currday_score=a1.user_currday_increment_score+a2.user_currday_score
     where a1.pt_day='2017-09-20' and a2.pt_day='2017-09-19'
       and a1.uid=a2.uid;
       update teach,stu set teach.tname='老师10',stu.tname='老师10' where stu.id=2
       
        update dingdan,shop set dingdan.dmount=dingdan.dmount+1,shop.smount=shop.smount-1 where dingdan.sname=shop.sname;
    ```

  - 第二种写法：

    ```py
    update xcs_user_credit_score a1 inner join xcs_user_credit_score a2 on a1.uid=a2.uid set a1.user_currday_score=a1.user_currday_increment_score+a2.user_currday_score where a1.pt_day='2017-09-20' and a2.pt_day='2017-09-19'
    update stu inner join teach on stu.id=teach.id set stu.tname=teach.tname
    
    ```

    

#### 复制表结构

- create table aaa like stu   只有表的结构

#### 复制表数据：

- insert into aaa select * from stu
- replace   into aaa (snamecid) values('张三',2)  一样的东西   引擎为unique，或者主键，他会替换，没有的话，就是添加   效率缓慢，因为要先查询，再决定干什么-L  数据库查询语言（Data Query Language）

日志管理： 操作数据库的历史纪录

- 错误日志   记录启动，运行或者停止时出现的问题，一般也会记录警告信息  一直开启

  - 错误日志文件：log_error  指定mysqld保存错误日志文件的位置
  - 启用警告信息  ： log_warnings  

- 一般查询日志   记录建立的客户端链接和执行的语句    一般不开启  说明：对除了慢查日志中记录的查询信息都将记录下来,这将对服务器主机产生大量的压力，所以对于繁忙的服务器应该关闭这个日志

  - q启动开关    general_log
  - 日志文件地址 general_log_file  
  - 全局日志开关   log={off|on}
  - `log_output = {TABLE|FILE|NONE} ``#指定存放查询日志的位置，可以放在文件中，也可以放在数据库的表中，放在表中比放在文件中更容易查看` 

- 慢查询日志   记录所有执行时间超过多少秒的所有查询或不适用索引的语句可以记录我们定位服务器性能问题   一般会打开

  - 查询超时时间  log_query_time 定义的默认时长 
  - 启动慢查日志  log_slow_querise={YES|NO}   这句话没用
  - 启动曼茶日志  slow_query_log={ON|OFF} 是否开启慢查询日志，默认是关闭的
  - 日志记录文件：slow_query _log_file [file] mysql如果启用了slow_query_log=on 选项，就能记录执行时间超过long_query_time的查询。日志文件如果

- 二进制日志 默认开启，精确的记录了用户对数据库中的数据进行操作的命令和操作的数据对象

  - 提供了增量备份的功能
  - 提供了数据基于时间点的恢复，这个恢复的时间点可以由用户控制
  - 为mysql的复制架构提供基础，将这主服务器的二进制日志复制到从服务器上并执行同样的操作，就可将数据进行同步

- 中继日志  主要是在mysql服务器的中从架构中的从服务器上用到的，当从服务器想要和主服务器进行数据的同步时，从服务器将主服务器的二进制日志文件拷贝到己的主机上放在中继日志中，然后调用SQL线程按照拷中继日志文件中的二进制日志文件执行以便就可达到数据的同步 

- 事务日志      运行事务的时候会产生 ，比如InnoDB支持事务，记录InnoDB等支持  innodb_flush_log_at_trx_commit:

  - - 0:每妙同步，并执行磁盘flush操作
    - 1：每事务同步，并执行磁盘flush操作
    - 2：每事务同步，单步执行磁盘flush操作

  mysql全局变量查询和修改：

  - 查询    show global variables 【like‘%log%’】

  - 修改    set global  variables_name=val

    ```py
    修改配置文件    ，找到端口，修改端口
    ```

### DQL 数据库查询语言：

```py
select   
column1，column2，
from
table——1
inner |left|right join table——2
where
group by
having group_conditions   可以认为这句是  group by的子查询
order by column_1
limit offset,length
```

#### 别名：

select count（tname） as num from teach    指定某列为什么

#### where：逻辑与比较   关键字

  比较运算符

```py
=           等于   几乎任何数据都能使用
<>或者!=    不等于
>           大于，数字和日期/时间数据类型
<          小于
<=       小于等于
>=        大于等于
```

##### 逻辑运算符：

or 或者    and 并且  not非

##### between 运算符：

- expr 【not】between    begin and  end    包含着等号  ，在大于等于和小于等于之间   如果expr的值大于等于begin并且小于等于 end，则运算符返回true，否则为0

- 指定时间范围    between cast('2013-01-01' as date) and cast('1980-10-01' as date)    

  cast  把 什么转化为什么格式

##### like 运算符：效率低   

- select * from teach where tname  like '%老师%'  不管老师前面和后面是什么
- select * from teach where tname  like '_老师'  老师前面只能有一个任意字符
- select * from teach where tanme like '%老\%师%'   把中间的%转义
- select * from teach where tanme like '%老$%师%'   escape '$'    把$作为转义字符

##### IN 操作字符   ：

- select  * from teach where birth in （‘1990’，‘1992’）
- find_in_set(1,2)      与in不同，in是确定的东西，而这个函数可以填写要查找的字符串，不用写字段里面全部的字符串
  - 第一个参数     要查找的字符传
  - 第二个参数   字段

##### group  by：

group by 子句必须出现在from 和where 子句后面，他是进行分组的，关键字之后是一个以逗号分割的列或表达式的列表，这些是要用作为条件来队形进行分组   

```py
分组往往会伴随着聚合函数  ,下面那都是几种函数
having是分完组后的筛选条件，分组后，使用聚合函数
avg()     计算一组值或表达式的平均值
count()   计算表中的函数
instr()       返回子字符串在字符串中第一次出现的位置
sun()  计算一组值或表达式的和
min()     最小值
max()   最大值
```

##### order by ：

- select  column1,column2  fromm order by  cid,fid   第一列为基准，第二列为第二基准，后面的列实在前一列的基础上进行的
- desc  降序， asc 升序 ，
-  自定义排序    select * from goods order by field (gname,'方便面','大米','纯净水') desc

##### limit:

- 两个参数   offset（偏移量，就是从那开始），count（取的数量），只有一个值，就代表取几个值
- limit 经常和order by 配合使用，用来查找最大值和最小值

##### 关联查询： 表与表之间有关，通过关系去查询  mysql 中没有out join 查询

- 交叉查询    cross join
  - ti 表中的hang 和t2表中的行组合起来  
  - 语法     select t1.id ，t2.id  from t1 cross join t2，笛卡尔乘积，所有的组合都展现出来
- 内链接 inner join
  - 谓词  on   select t1.id ，t2.id  from t1 inner join t2 on t1.cid=t2.cid
- 左连接   left join
- 右连接    right join

##### 联合查询：把多个select 语句查询的结果合并起来

- 语法：select  id1 from table1 union select id2 from table2

- 特点：

  - 查询的结果列名是以第一个列明为基准的

  - 会自动把重复项去掉（比如三个班，你都退出来，信息都存在。查总数）

  - select  id1 from table1 union all select id2 from table2  不会去掉重复项

  - 可以与order by 一起用，某列信息没有什么大小顺序的话，会自动按照拼音字母进行排序

    ```py
    gname，num，price，dt，cid   goods
    
    cname   category
    
    select count(*) from goods group by cid;    
    
    select sum(price*num) from goods group by cid;   按照分类去算价钱
    
    按照时间去算价钱
    
    查询食品和饮品一月份到三月份的超过100的
    
    select sum(num*price) as total from goods where cid!=1 group by dt having total>100
    ```

##### 子查询：

- 标量子查询 ：返回单一值的标量，最简单的形式,如一个数字或一个字符串    括号里面弄出来的是单一的

  - 语法   select * from article where uid = （select uid from user where status=1 order by desc limit ）

- 列子查询： 返回的结果集是N行一列

  - select * from goods where cid in (select id from category where cname='食品' || cname='饮品')
  - any   可以关系运算符一起用   ，小于 其中的任何一个数据就可以      语法  ：select * from goods where cid < any(select id from category where id =2 or id =3)
  - all   可以与关系运算符一起用 ,小于其中的所有数据

- 行子查询： 返回的结果集是一行N列

  - 得到的是一行信息      
  - select   * from orders where （oname，cid）=（select gname，cid from goods where gname=‘男装’）

- 表子查询：返回的结果集是N行N 列

  - select  * from orders where （oname，cid）=（select gname，cid from goods）

  exists  无论输入子查询是否返回行，

  语法： select * from citys where city = ‘hangzhou’ and exists(select id from dingdan )

### 常用内置函数：

#### 聚合函数    

- count()   返回列表中的行数

- avg()  返回平均值   如果有一个数据为null，则会忽略

- sum（【可以写表达式  price*num】）  求总和  

- max （ ）  最大

- min（） 最小

- group_concat()     函数   语法select group_concat(gname)  from goods  group by cid

  ```py
   男装,女装,童装       |
  | 牛肉,猪肉,鸭肉       |
  | 阿萨姆,小洋人,真果粒 |
  | 工具
  ```

  

#### 字符串函数

- concat （'1','2'）= 12     select concat(firstname,lastname) from names  和 concat_ws(-,firstname,lastname)   firstname-lastname 链接两个或多个引用的字符串值
- left()     他返回具有指定字符串的长度的左边部分   select  left（‘abcdef’，3）=abc
- replace （str，old，new）  select replace（this is a persoc ，persoc，person）   它允许您用新的字符串替换表的列中的字符串   语法： select replace('zhansgan','zhans','sss')=sssgan
- substring  （‘abcdefg’，1（开始位置,下标从1开始），2（个数））
- trim(【{both|leading（）开始位置|trailing（右边）}】【remove——str】(药要删除的字符串)from str)      select trim('   abc   ')     select trim(leading from'   abc   ')   删除空格
- format（n，d，格式）n 要格式化的数字   d  要舍入的小数位数   de_DE  需要加引号  .分割千位，分割小数位

- 日期和时间函数

  - 返回当前日期

    - curdate（）  返回当前的日期   只显示日期
    - now（）    还带有 时间   程序执行的开始时间
    - sysdate（）   程序的开始时间，程序执行，他也会算时间   区分：now(),sleep(),now()

  - 返回指定日期

    - day（now（））   天
    - month（now（））月
    - year （now（））年
    - week （now（））第几周
    - weekday（now（）） 礼拜几，星期一为0
    - dayname（now（））   英文的写法      set @@lc_time_names='zh_CN'   可以把英文的写法写成中文    en_US

  - 日期计算函数

    - datediff ()    接受两个参数   ，只算日期，没时间    datediff('日期一','日期二')  前面的减去后面的

    - timediff('2018-01-01 12:00:00','2018-01-02 12:00:00')  时间月日期都能算

    - timestampdiff(unit,begin,end)

      - unit :  以什么单位显示
        - microsecond
        - second
        - minute
        - hour
        - day
        - week
        - quarter
        - year

    - date_add(start_data,interval expr unit)   将间隔时间添加到date 或者datetime        开始时间  要添加到其实日期值的间隔值   一个符合日期格式的字符串       单位  

      ```py
       '2018-12-31 23:59:59' inrerval  ‘1：1’ minute_second
      ```

    - date_sub()   和上面用法一样，只不过是减法

### 视图：类型  简化查询经常用

> 在mysql，经常回有一些复杂的查询，对于复杂的查询，

#### 创建视图     create view  viewname  as  select cname,gname,price,num,dt   from 

#### 修改视图   alter view viewname as 

#### 使用    create or replace view viewname as 语句修改视图

#### 删除表   drop view  if exists 库名+表名

#### 查看视图    show create view viewname    show table viewname

### 临时表    简化查询  

> 多表查询的时候  偶尔用，生命周器就是会话的时间，连接上数据库直到关闭

- 创建临时表    create temporary table temp  select。。。

### TCL 事务控制语言  

#### 事务

> 事务是数据库处理操作，其中执行就好像它是一个单一的一组有序的工作单位，换言之在组内每个单独的操作是成功的，那么一个事务才是完整的，如果事务中的任何操作失败，整个事务将失败

#### 事务性质：

- 原子性：确保了工作单位中的所有操作都成功完成，否则，事务被终止，在失败时会被回滚到事务操作以前的状态      一个事务有很多事件组成，事务最小的组成单位就是事件，原子本意就是最小的组成单位，以此来描述最合适不过了  **事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。** 
- 一致性：可确保数据库在正确的更改状态在一个成功提交事务    一个数据库中有很多的表，在同一个时间段内，可能会有很多的人去执行事务操作，但是一个人要进行删除，一个要进行修改，如何才能让他保持一致性那，谁先执行，听谁的  **事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。** 
- 隔离：使事务相互独立地操作   每个事务都是相互独立的，一个事务可以执行好几个事件，另一个事务也需要执行几个事件，但是这几个事件又是相同的，到底怎么样执行，所以要把他们隔离开来，分开执行  **同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。** 
- 持久性：确保了提交事务的结果或系统故障情况下仍然存在作用  事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

#### 事务控制语句：（这个旨在innodb）

- begin 或start transaction ：显式地开启一个事务

  ```py
  写下  begin后，写操作语句，现在只是保存在内存中，不会提交到数据库，其他用户看不到你的操作信息，操作完后，写下commit
  ```

  

- commit：也可以使用commit work，不过二者是等价的。commit会提交事务，并使已对数据库进行的所有修改成为永久性的

- rollback ：有可以使用rollback work，不过二者是等价的，回滚会结束用户的事务，并撤销正在进行的所有未提交的修改

  ```py
  前面修改的没提交的所有东西，都没用
  ```

  

- set autocommit = 0 禁止自动提交   只是把他提交到内存中，不会到数据库，需要写commit    当前窗口,用查询变量的语句    show global variables like 'autocommit',在当前窗口，不需要查看全局的，所以不用写global，更改也是一样，

- set autocommit = 1 开启自动提交

  ```py
  python 中的使用
  import pymysql
  db = pymysql.connect('localhost','root','zkw986606015','demo_py')
  cursor = db.cursor()
  # db.autocommit(1)
  # try
  # except
  # else:
  # data = [[i] for i in range(10000)]
  try:
      cursor.execute('insert into inno (name) values ("zkw")')
      cursor.execue('insert into inno (name) values (22)')
  except:
      cursor.execute('rollback')
      # 发生错误会回滚
  else:
      cursor.execute('commit')
  # db.commit()
  ```

  

#### 事务支持的表类型：

- 有许多类型的表其支持事务，但目前最流行的一种是：InnoDB
- 可以使用其他类型的表GEMINI 或 BDB,但他取决于安装mysql时，是否支持这两种引擎

### 什么是锁：

> ​	锁是计算机协调多个进程并发访问某一资源的机制，在数据库中，除传统的计算资源（如cpu，ram，i/o）的争用以外，数据也是一种供多种用户共享的资源。如何保证数据并发访问的一致性，有效性是所有数据库必须要解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤为重要，也更加复杂，mysql用到了很多的这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁，这些锁统称为悲观锁

### 数据库锁

> ​	相对于其他数据库而言，Mysql数据库的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁，BDB 采用的是页面锁，但也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下时行级锁

- 表级锁   并发速度很糟糕，开销小，运行速度很快，不支持事务   开销小，加速快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低

  - 共享读锁 读锁（防止别人上独咱锁，其他人只能读，不能改，自己也不能改） 独占/写锁（其他人看也看不到，写锁的级别比较高，也叫排他锁）

  - 表级锁的存储引擎：MySIAM   memory

  - 特点：

    - 作用范围在表的级别
    - 如果加了读锁，对于mysiam表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求      这个用户给一个表加了读锁，那么这个用户只能对这个表进行读操作，不能进行写操作，否则会报错，而其他用户只能进行读操作，想要进行写操作，必须等这个用户释放锁才行
    - 如果加了读锁，可以查询锁定表中的记录，但更新或访问其他表都会提示错误    这个用户只能访问这个表，访问其他表会报错，这叫不能太贪心，而其他用户当然可以访问其他表
    - 如果加了写锁，对mysiam表的写操作，则会阻塞其他用户对同一表的写和读操作，自己可以进行任何操作
    - 如果加了写锁，可以读写表中的记录，但更新或访问其他表都会报错，不能太贪心

  - 如何加表所

    > MsiSAM 再执行select语句前，会自动给涉及的所有表加读锁，再执行更新操作（update，delete，insert）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一版不需要直接用lock table 命令 给MyISAM 显式加锁

    - 加锁   

      ```py
      lock tables 表明 read/write [local](加上这个关键字，进行模拟表),   加读/写表锁 ,其实这里面的操作在pymyql中同样适用，，都是一样的原理
      ```

    - 多表加锁

      ```py
      lock tables 
      ```

    - 释放锁

      ```py
      unlock tables ;
      ```

    - 查询表级锁争用情况

      ```py
      show status like 'table%';   加锁的次数，等待的次数,累加
      show status like '%lock%';  
      show processlist;  此命令可以查询那些sql在等待锁
      show open tables;   当前被锁的表和锁得次数
      当 table_locks_waited 与 table_locks_immediate的比值较大时，说明造成的堵塞比较严重
      ```

    - 并发插入：

      - concurrent_insert    0   不允许并发插入   nerve
      - 1 auto 允许并发插入    如果MyISAM表中没有空洞，（即表的中间没有被删除的行）即使锁了，MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录，mysql的默认设置
      - 2  always 不管MyISAM表中有没有空洞 允许在表尾并发插入记录

    - 读写锁优先级 

      > ​	默认情况下，写的优先级高于读，即使是先发送的读请求，后发送的写请求，也会优先处理写请求，然后再处理读请求,这就造成一个问题，一旦我发出若干个写请求，就会造成读请求的阻塞，知道写请求全部处理完，才会有机会处理读请求，有下面几种方式请求

      - 设置写锁的最多次数  ？？？？

        ```py
        max_write_lock_count=1
        这句话代表的意思是第一个写锁，第二个写锁，第三个写锁，第四个读锁，第一个写锁开启，第二个锁开启，就进行读锁，然后进行写锁
        有了这样的设置，当系统处理一个写操作后，就会暂停写操作，给读操作执行的机会
        ```

      - 降低写操作的优先级，给读操作更高的优先级

        ```py
        low_priority_updates=1  ,可以用 low_priority 这个关键字，这个关键字是在更新语句的时候
        还要设置一下 sql_low_priority_updates=1
        再用insert update delete  的时候要加上  low_priority 关键字
        insert low_priority into inno (name) values('222')
        ```

    - 设置写内存   根据具体的业务设置读写内存

      ```py
      max_allowed_packet=1M  限制接受的数据包大小，大的插入和更新会被限制掉导致失败
      net _buffer_length=2k   insert 语句缓存值，2k-16M
      bulk_insert_buffer_size=8M        一次性insert语句插入的大小
      ```

    - 如何优化：

      - 利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。例如，将concurrent_insert 系统变量为2，总是允许并发插入
      - 同时，通过定期咋i系统空闲时段执行  optmize table 语句来整理空间碎片，收回因删除记录而产生的中间空洞
      - 是否设置写的优先级，是场景而定，解决查询相对重要的应用（如用户登陆系统）中
      - 是否设置写内存，解决批量插入数据（新闻数据系统更新）场景中

- 行级锁    只锁住一行，开销很大，每条数据都得记住，谁在访问，是否锁住了    开销大，加锁慢；会出现死锁；锁定力度小，发生锁冲突的概率最低，并发度也最高  行锁也叫事务锁

  > mysql 的行级锁有两种方式：
  >
  > 共享锁（s）：允许一个事务去读一行，组织其他事务获得相同数据集的排他锁
  >
  > 排他锁（x）：允许获得排他锁的事务更新数据，组织其他事务取得共同数据集的共享读锁和排他写锁
  >
  > 意向共享锁（is）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的is锁
  >
  > 意向排他锁（ix）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁之前必须先取得该表的ix锁

  如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反子，如果两者不兼容，该事务就要等待锁释放

  对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。 

  | 请求模式 是否兼容 当前锁模式 | x    | ix   | s    | is   |
  | ---------------------------- | ---- | ---- | ---- | ---- |
  | x                            | 冲突 | 冲突 | 冲突 | 冲突 |
  | ix                           | 冲突 | 兼容 | 冲突 | 兼容 |
  | s                            | 冲突 | 冲突 | 兼容 | 兼容 |
  | is                           | 冲突 | 兼容 | 兼容 | 兼容 |

  行锁级的存储引擎： InnoDB    5.5以上

  行级锁的特点：

  - InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁        想要设置行锁，必须这个字段添加索引

  - 意向锁是InnoDB自动加的，不需要用户干预，对于update，delete，insert语句，会自动给加上排他锁，对于select语句，不会加任何锁

  - 在研究行锁的时候，需要将自动提交关闭，默认为开启

    ```py
    set autocommit = 0
    ```

    多个客户端，都要设置

  如何给select加行锁

  > ​	给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取

  加锁

  ```py
  共享锁   select * from tablename where ...lock in share mode
  排他锁   select * from tablename where ...for update
  ```

  共享锁主要在需要数据依存关系时来确认某行记录是否存在，并确保没有人对则个记录进行update或者delete操作，但是共享锁容易导致死锁。锁定行记录后需要进行更新操作的应用，应该使用排他锁

  释放锁

  ```py
  commit;
  rollback;
  ```

  特点：

  当我们正在给某条数据上排他锁的时候，其他人想进行写操作这条数据的时候会没法执行，但是可以读数据，只不过在默认的innodb隔离方式下，查询数据的时候，查询的是以前没跟新的信息，当我们给一条数据加了排他锁（update，delete，insert）其他人对于这条数据没有任何权限，但是他并不影响别人去访问其他数据，查询的时候可以查询，但是是以前的信息

  如果引擎时innodb，如果你正在操作的字段并且你使用的这个条件没有索引，行锁会自动升级为表锁

  即使你给一个字段加了索引，但是用这个字段的时候，你把他的类型改变了，那么索引失效，还是会给他加上表所

  间隙所：四条数据，删除了第二条数据，操作>1的数据，另一个人想要插入，有关操作的，会被锁住，指定条件时要确定范围，

  默认的一种隔离方式，不提交看不到新消息

  注意事项：

  - 没有索引行锁转换为表所

  - 索引的数据类型变化会导致行锁失效，转换为表所

    ```py
    当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，innodb会给符合条件的已有数据的索引项
    update inno set name=‘aaa’ where id>4 and id <9  该范围缺少7
    insert into inno （id，name） values （7，‘123’） 因为间隙所，所以阻塞
    特别要说明的是，innodb除了通过范围条件加锁时等条件请求给一个不存在的记录加锁
    ```

    

  查看行级锁争用情况：

  - show status  like  'innodb_row_lock%'

  事务并发的问题：

  - 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据时脏数据
  - 不可重复读：事务A多次读取同一数据时，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致
  - 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读

  不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题时，只需要锁住满足条件的行，解决幻读需要锁表

  mysql事务隔离级别：

  | 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 描述                                                         |
  | ---------------------------- | ---- | ---------- | ---- | ------------------------------------------------------------ |
  | 读未提交（read-uncommitted） | 是   | 是         | 是   | 该隔离级别指即使一个事务的更新语句没有提交，但是别的事务可以读到这个改变，几种异常情况都可能出现，极易出错，没有安全感 |
  | 不可重复读（read-committed） | 否   | 是         | 是   |                                                              |
  | 可重复读（repeatable-read）  | 否   | 否         | 是   |                                                              |
  | 串行化（serializable）       | 否   | 否         | 否   |                                                              |

  各个隔离级别的情况：

  - 查看隔离级别

    ```py
    select @@session.tx_isolation;
    ```

  - 设置隔离级别

    ```py
    set session transaction isolation level read uncommited
    ```

    mysql     数据结构    B树   排序    加了索引，会消耗内存      不加索引，在硬盘，搜索速度会很慢，二叉树 

  1、读未提交

  - 打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），创建表goods，添加几条信息
  - 在客户端A的事务提交之前，打开另一个客户端B，更新表goods
  - 这时，虽然客户端B的事务还没有提交，但是客户端A就可以直接查询到B已经更新的数据
  - 一旦客户端B的事务因为某种原因回滚，所有的操作都会被撤消，那客户端A查询道德数据就是脏数据
  - 在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别 

  2、读已提交

  - 打开一个客户端A，并设置当前事务模式为read commited（读已提交模式），查询创建表goods的所有记录
  - 在客户端A的事务提交之前，打开另一个客户端B，更新表goods
  - 这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题
  - 客户端B的事务提交
  - 客户端A执行与上一步相同的查询，结果与上一步不一致，即产生了不可重复度的问题

  3、可重复度   mvcc机制    多版本并发控制（mvcc，multiversion）

  - 打开一个客户端A，并设置当前事务模式为repeatable read，查询表goods的所有记录
  - 在客户端A的事务提交之前，打开另一个客户端B，更新表并提交
  - 在客户端A查询表goods的所有记录，与步骤1查询结果一致，没有出现不可重复读的问题
  - 在客户端A，接着执行update price=price-100，price的结果确实没有被破坏，可重复的的隔离级别使用了mvcc机制，select结果不会更新版本号，最快照度（历史版本）

  ```py
  每一行都是一个事务，
  ```

  4、串行化

  - 打开一个客户端A，并设置当前事务模式为zerializable，查询表goods的初始值
  - 打开一个客户端B，

  如何优化行级锁：

  - 尽量使用较低的隔离级别：精心设计索引，并尽量使用索引访问数据，使加锁更准确，从而减少锁冲突的机会
  - 选择合理的事务大小，小事务发生锁冲突的几率也更小
  - 给记录集显式加锁时，最好一次性请求足够级别的锁，如果要修改数据的话，最好直接申请排他锁，而不是申请共享锁，修改时咋i申请排他锁，这样容易产生死锁
  - 尽量使用相等条件访问数据，这样可以避免间隙所对并发插入的影响 ，用大于或小于，间隙所
  - 对于一些特定的事务，可以使用表所来提高处理速度或减少死锁的可能

- 页面锁     开销和加锁时间介于表锁和行锁之间；会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般

### 主从配置

#### 主从复制：

> 在实际生产环境中，由单台mysql数据库是不能完全满足实际需求无论安全性，高可用性以及高并发等各个方面的要求，mysql主从复制是满足这些要求的基础，它主要用于mysql的实时备份，高可用，读写分离等场景。

原理图

![img](https://images2015.cnblogs.com/blog/820365/201608/820365-20160821160615776-1749314661.png) 

数据库连接起来，操作二进制日志，操作中继日志

#### 主从复制配置过程：

- 要求

  - 两台服务器

  - 双方mysql一直，如不一致，主要主节点低于从节点

  - 两台服务器防火墙关闭掉  

    ```py
    linux  防火墙关闭  
    sudo ufw status/disable
    ```

    

  - 双方数据库所用的用户，要具有远程访问的权限

- 主服务器防火墙设置    windows（my.ini）  linux(my.cnf)

  ```py
  #mysql唯一id
  server-id=1
  #二进制日志文件，此项为必填项，否则不能同步数据；
  log-bin="mysql-bin"
  #指定二进制错误文件
  log-error="mysql-error"
  #需要同步的数据库，如果需要同步多个数据库：
  binlog-do-db=demo
  #binlog-do-db=slaveDB1
  #binlog-do-db=slaveDB2
  #不需要同步的数据库
  binlog-ignore-db=mysql
  把bindadress这句话注释了  
  ```

- 授权给从数据库服务器

  ```py
  grant replication slave on *.* to 'root'@'从服务器地址'  identified by '123456'  flush privileges;
  ```

- 重启主服务器

  ```py
  service mysqld restart
  
  sudo /etc/init.d/mysql restart
  windows在服务那从新启动即可
  ```

- 查看主服务器BIN日志的信息（执行完之后记录下这两个值）

  ```py
  show master status 
  ```

- 配置从服务器

  ```py
  修改从服务器的mysql配置文件，注意ID没有被别的mysql服务占用
  server-id=2 #默认是1改成2
  下面也有一句这个，把他改成2
  log-bin="mysql-bin" #这本身有
  replicate-do-db=demo #需要同步的数据库
  replicate-ignore-db=mysql #不需要同步的数据库
  read_only #只读权限
  
  mysql_error.000002 107 demo_data mysql
  ```

- 启动mysql服务

- 执行同步sql语句

  ```py
  change master to
  master_host='111.111.111.111', #设置要连接的主服务器IP地址
  master_user='root', #设置要连接的主服务器用户名
  master_password='123456', #设置要连接的主服务器密码
  master_log_file='mysql-bin.000002', #设置要连接的主服务器bin日志的日志名称
  master_log_pos=1041; #设置要连接的主服务器bin日志的记录位置
  change master to
  master_host='192.168.187.129',
  master_user='root',
  master_password='123456', 
  master_log_file='mysql-bin.000010', 
  master_log_pos=107
  ```

  

- 启动slave同步进程

  ```py
  #查看状态
  show_slave status\G
  #其中Slave_IO_Running Slave_SQL_Running值都是YES，表示状态正常
  #如果之前从服务器启动过需要先停止在运行
  先stop slave
  后start slave
  ```

- 主从同步检查

- show slave  status\G

- io 与 sql

作用     灾备，读写分离，负载均衡   集群

### 二进制日志:

> 二进制日志是一个二进制文件，主要用于记录修改数据或有可能引起数据变更的mysql语句，二进制日志中记录了对mysql数据库更嘎的所有操作，并记录了语句发生时间。执行时长。操作数据等其他额外信息，但是他不记录select，show等那些不修改数据的sql语句。二进制日志，主要用于数据库回复和主从复制，以及审计等操作。

#### 二进制日志开启：

- 查看系统变量log_bin，如果其值为off，表示没有开启二进制日志

- 开启二进制日志，则必须在my.cnf 中 [mysqld] 下面添加 log-bin=[=DIR[filename]],DIR参数指定二进制文件的存储路径；filename 参数指定二进制文件的文件名

- 系统变量是log_bin是静态参数，不能动态修改的

- 修改配置文件，mysqld里面加入log_bin=mysql_bin_log，重启Mysql后，你就会发现log_bin变为了ON，二进制文件（binary log）默认放在数据目录下（系统变量datadir下）

  ```py
  show variables like 'datadir'
  show variables like  'log_bin'
  show variables like '%log_bin%'
  ```

查看二进制文件

- 查看当前服务器所有的二进制日志文件

```py
show binary logs;
show master logs;
```

- 查看当前日志状态

  ```py
  show master status
  ```

删除二进制文件

- 删除某个文件之前的二进制文件

  ```py
  purge binary logs to xxx    xxx之前的
  ```

- 清除所有日志文件

  ```py
  reset master
  ```

- 自动清理

  > ​	设置 'expire_logs_days' 参数

  ```py
  show variables like 'expire_logs_days'
  set expire_logs_days=7
  ```

### 数据库优化操作

硬件 系统配置  数据库表结构  sql即索引  成本   效果

mysql 逻辑结构

innodb存储的是引擎

#### explain 参数详解

> 查询语句hi我们在使用mysql的频率最高的语句，也是影响性能ui重要的环节，

sql编写流程

```py
select * from stu where cc=1 group by id desc having 
```



sql执行流程

使用方式

```py
explain  select * from uek_table 
```

执行效果

```py

```

各种参数详解

- id    id是sql执行的 顺序的标识

  -  id相同时，执行顺序由上至下（由于表的数据量大小决定执行顺序）越先执行,数据越少查询越靠前  2乘以3乘以5   和   5乘以3 乘以2  两句内存不一样，执行效率不同，前面的快
  -  如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
  - id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高

- select_type    查询每个select子句的类型

  1) SIMPLE(简单SELECT,不使用UNION或子查询等)

  (2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)

  (3) UNION(UNION中的第二个或后面的SELECT语句)

  (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)

  (5) UNION RESULT(UNION的结果)

  (6) SUBQUERY(子查询中的第一个SELECT)

  (7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)

  (8) DERIVED(派生表的SELECT, FROM子句的子查询)

  select aa.cname from (select cname,tid from course) as aa

  (9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

- table   显示表名称 显示这一行的数据是关于那张表的，

- type   

  > 表示mysql在表中找到所需行的方式，又称访问类型,代表性  all<index<range<ref<eq_ref<const<system<NULL

  - ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行，并且查找的内容不带索引
  - index: Full Index Scan，index与ALL区别为index类型只遍历索引树，也就是查找有索引的列
  - range:只检索给定范围的行，查找的内容不带索引，选择的行带索引，可以用between,但是不要用in,因为他会破坏掉所有的索引
  - ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值,能用具体的值就别用区间
  - eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
  - const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system，在衍生表中查询，就是派生表
  - NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

- possible_keys  可能会用到的索引

- key

- key_len  索引在内存中占的字节

- ref

- rows

- Extra  

  - using temporary     临时在内存中创建表

  - use index：

  - use  where 

  - using filesort  mysql 进行可多次排序，灭有利用索引进行排序，说明性能很低

    ```py
    创建一个复合索引的表
    one varchar(100)
    two varchar(100)
    three varchar(100)
    index one (one)
    index two (two)
    index three (three)
    select * from demo where one='' order by one;
    最佳左前缀
    一旦加了复合索引之后，索引的使用顺序一i的那个要按照你加的索引顺序，这样才能提高效率
    排序最好用主键排序
    ```

    

  - impossible WHE   证明查询语句错误，不会报错

  - using join buffer 该值强调了在获取链接条件时没有使用索引，并且需要链接缓冲区

#### mysql优化方法

- 优化工具

  - 通过使用explain命分析sql语句的运行效率
  - 通过开启慢查询开查看运行效率慢的sql语句

- 索引优化

  > 索引是我们提升sql查询效率的重要手段，同时索引的使用不当也会带来性能的问题的时候，因该注意以下问题

  - 不能将索引做表达式的一部分，也不能是函数的参数

    ```py
    select * from demo where id+=1;
    select max(id) from demo where id=1
    select sex from teach where left(tname,3)=''
    ```

  - 索引不要进行类型转化，否则索引失效

    ```py
    select * from demo where tname=1;
    tname 的类型是字符串
    ```

  - 复合索引遵循左前缀策略

  - 复合索引不能用or关键字，否则失效

    ```py
    select * from demo where one="" or two=""
    ```

  - 复合索引不能使用!=或者is null <>

  - 尽量不能和in一起使用，导致索引失效

    ```py
    select * from course where id=1
    select * from course where id in(1,2,3)
    ```

  - 及时删除冗长和长期不使用的索引

  - 使用like 的时候不要使用左边的%号,否则索引会失效

#### 单多表sql优化操作

- 单表案例

  > ​	有一个表用来记录书籍的名字，出版号，作者，类型，然后查询其中两种类型并且属于同一个作者，然后按照出版号来进行排序

  ```py
  create table book(
  id int(10) auto_increment primary key,
  bookname varchar(100) not null,
  authorid  varchar(100)
  publickcid int（10）
  typeid int(10)
  )
  select * from book where typeid in(1,2) and authorid=1 order by publicid
  ```

  - 加索引（并且加在频繁使用的字段上）
  - 调整索引顺序（遵循左前缀原则）
  - 删除多余索引
  - 调整查询条件，对索引右干扰的语句放到条件的最后

- 多表案例

  - 小表驱动大表    （小表在前面，大表在后面   where 小表.id = 大表.id）
  - left join 给左表加索引，right join给右边加索引

- 表级别锁优化

- 系统级别优化

  - 主从复制
  - 读写分离
  - 负载均衡

- 其他优化总结

  - 通常来说可以把null的列改为not null 不会对性能提升有多少帮助，只是如果不指定
  - 对于数据哪个
  - unsigend 表示不允许负值，大致可以使
  - 通常来说，没有太大的必要使用decimal
  - timestamp 使用4个字节
  - 大多数情况下美誉使用枚举类型的必要
  - 表的列不要太多，如果列太多而实际使用的列又很少的话，有可能会导致cup占用过高，选择数据类型

distinct  去重

复合索引   add  index a_b_c(tname,iid,sex)

explain  select tname from teach where sex=''

20 * 3  +20* 3 +10   utf8 ,尽量在单字节或者数值类型中添加索引，在字符串

not  null节省内存，null的话是空的，但是咱内存

rdbms   图标是海豚

复合件

完整性：

- 参照完整
- 尸体完整
- 域完整性

进入Mysql 安装的bin目录

net

service 

#### explain  分析语句性能   type  查询速度

```py
id     课程的名字   老师的id

id  老师的名字      简介的id

id   简介  

select     简单查询    联合   子查询   关联子查询

explain  分析语句性能   type  查询速度

简单查询：select con from jianjie,user,kecheng where user.jid=jianjie.id and kecheng.uid=user.id and kecheng.id=1;

关联查询： select con from jianjie join user on jianjie.id=user.jid join kecheng on kecheng.uid=user.id where kecheng.id=1;

子查询：select con from jianjie where id = (select jid from user where id=(select uid from kecheng where id=1));

 关联与子查询相结合：select con from jianjie join user on jianjie.id=user.jid where user.id=(select id from kecheng where id=1);

```



id  老师的名字      简介的id

id   简介  

select     简单查询    联合   子查询   关联子查询

explain  分析语句性能   type  查询速度

简单查询：select con from jianjie,user,kecheng where user.jid=jianjie.id and kecheng.uid=user.id and kecheng.id=1;

关联查询： select con from jianjie join user on jianjie.id=user.jid join kecheng on kecheng.uid=user.id where kecheng.id=1;

子查询：select con from jianjie where id = (select jid from user where id=(select uid from kecheng where id=1));

 关联与子查询相结合：select con from jianjie join user on jianjie.id=user.jid where user.id=(select id from kecheng where id=1);







pip freeze>r.txt

pip install r.txt